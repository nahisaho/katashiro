#!/usr/bin/env node
/**
 * KATASHIRO CLI - AI Research & Analysis Tool
 *
 * @requirement REQ-CLI-001
 * @design DES-KATASHIRO-001 Â§2.6 CLI Interface
 */

import { Command } from 'commander';
import { createRequire } from 'module';
import { mkdir, writeFile } from 'fs/promises';
import { dirname, join } from 'path';
import {
  WebSearchClient,
  WebScraper,
  TextAnalyzer,
  EntityExtractor,
  SummaryGenerator,
  isOk,
  isErr,
} from './index.js';
import {
  ResearchEngine,
  createProviderFactory,
  createLMReasoning,
  FetchLMProvider,
} from '@nahisaho/katashiro-collector';
import type { ResearchReport, ResearchEvent, Reference } from '@nahisaho/katashiro-collector';
import {
  createContent,
  isValidFormat,
  isValidProvider,
  parseNumberOption,
  formatSearchResult,
  formatError,
  truncateText
} from './cli-helpers.js';

// package.json ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—
const require = createRequire(import.meta.url);
const pkg = require('../package.json');

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒãªã‘ã‚Œã°è‡ªå‹•ä½œæˆï¼‰
 */
async function saveReport(filePath: string, content: string): Promise<void> {
  const dir = dirname(filePath);
  await mkdir(dir, { recursive: true });
  await writeFile(filePath, content, 'utf-8');
}

/**
 * å‚ç…§IDãƒãƒƒãƒ—ã‚’ä½œæˆï¼ˆURLã‹ã‚‰å‚ç…§IDã¸ï¼‰
 */
function buildReferenceMap(references: Reference[]): Map<string, string> {
  const map = new Map<string, string>();
  for (const ref of references) {
    map.set(ref.url, ref.id);
  }
  return map;
}

/**
 * Deep Research v3.0.0 çµæœã‚’Markdownãƒ¬ãƒãƒ¼ãƒˆã«å¤‰æ›ï¼ˆå¼•ç”¨ä»˜ãï¼‰
 */
function generateMarkdownReportV3(report: ResearchReport): string {
  const lines: string[] = [];
  const now = new Date().toISOString().split('T')[0];
  const referenceMap = buildReferenceMap(report.references);
  
  lines.push(`# ${report.query}`);
  lines.push('');
  lines.push(`> Generated by KATASHIRO Deep Research v3.0.0 on ${now}`);
  lines.push('');
  
  // çµ±è¨ˆ
  lines.push('## ğŸ“ˆ çµ±è¨ˆ');
  lines.push('');
  lines.push(`| é …ç›® | å€¤ |`);
  lines.push(`| --- | --- |`);
  lines.push(`| ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | ${report.metadata.iterations} |`);
  lines.push(`| ä½¿ç”¨ãƒˆãƒ¼ã‚¯ãƒ³ | ${report.metadata.tokensUsed} |`);
  lines.push(`| å®Ÿè¡Œæ™‚é–“ | ${(report.metadata.durationMs / 1000).toFixed(1)}ç§’ |`);
  lines.push(`| ä¿¡é ¼åº¦ | ${(report.metadata.confidence * 100).toFixed(0)}% |`);
  lines.push(`| åé›†çŸ¥è­˜ | ${report.metadata.knowledgeCount}ä»¶ |`);
  lines.push(`| è¨ªå•URL | ${report.metadata.urlsVisited}ä»¶ |`);
  lines.push('');
  
  // æ¦‚è¦
  lines.push('## ğŸ“ æ¦‚è¦');
  lines.push('');
  lines.push(report.summary);
  lines.push('');

  // ä¸»è¦ãªç™ºè¦‹ï¼ˆå¼•ç”¨ä»˜ãï¼‰
  if (report.findings.length > 0) {
    lines.push('## ğŸ“‹ ä¸»è¦ãªç™ºè¦‹');
    lines.push('');
    lines.push('> å„ç™ºè¦‹äº‹é …ã«ã¯å¼•ç”¨å…ƒã‚’ `[ref-N]` å½¢å¼ã§æ˜è¨˜ã—ã¦ã„ã¾ã™ã€‚');
    lines.push('');
    
    for (let i = 0; i < report.findings.length; i++) {
      const finding = report.findings[i];
      if (!finding) continue;
      
      // å¼•ç”¨ã‚’æŒ¿å…¥
      const citations = finding.citations
        .map((url: string) => referenceMap.get(url))
        .filter(Boolean)
        .map((id: string | undefined) => `[${id}]`)
        .join(' ');
      
      lines.push(`### ${i + 1}. ç™ºè¦‹äº‹é …`);
      lines.push('');
      lines.push(`${finding.statement}`);
      if (citations) {
        lines.push('');
        lines.push(`**å¼•ç”¨å…ƒ:** ${citations}`);
      }
      lines.push('');
      lines.push(`*ä¿¡é ¼åº¦: ${(finding.confidence * 100).toFixed(0)}%*`);
      lines.push('');
    }
  }
  
  // é¸æŠè‚¢
  if (report.options.length > 0) {
    lines.push('## ğŸ”€ é¸æŠè‚¢');
    lines.push('');
    for (const option of report.options) {
      lines.push(`### ${option.name}`);
      lines.push('');
      lines.push(option.description);
      lines.push('');
    }
  }
  
  // æ¨å¥¨äº‹é …
  if (report.recommendations.length > 0) {
    lines.push('## ğŸ’¡ æ¨å¥¨äº‹é …');
    lines.push('');
    for (const rec of report.recommendations) {
      lines.push(`${rec.priority}. **${rec.recommendation}**`);
      lines.push(`   - ç†ç”±: ${rec.rationale}`);
      lines.push('');
    }
  }
  
  // å‚è€ƒæ–‡çŒ®ï¼ˆå¼•ç”¨ãƒªã‚¹ãƒˆï¼‰
  lines.push('## ğŸ“š å‚è€ƒæ–‡çŒ®');
  lines.push('');
  lines.push('> æœ¬ãƒ¬ãƒãƒ¼ãƒˆã§ä½¿ç”¨ã—ãŸæƒ…å ±æºã®ä¸€è¦§ã§ã™ã€‚æœ¬æ–‡ä¸­ã® `[ref-N]` ã¯ä»¥ä¸‹ã®å‚è€ƒæ–‡çŒ®ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚');
  lines.push('');
  for (const ref of report.references) {
    lines.push(`- **[${ref.id}]** [${ref.title}](${ref.url}) (ã‚¢ã‚¯ã‚»ã‚¹: ${ref.accessDate})`);
  }
  lines.push('');
  
  return lines.join('\n');
}

const program = new Command();

program
  .name('katashiro')
  .description('KATASHIRO CLI - AI Research & Analysis Tool')
  .version(pkg.version, '-v, --version', 'ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ç¤º');

// æ¤œç´¢ã‚³ãƒãƒ³ãƒ‰
program
  .command('search <query>')
  .description('Webæ¤œç´¢ã‚’å®Ÿè¡Œ')
  .option('-n, --max <number>', 'çµæœã®æœ€å¤§ä»¶æ•°', '10')
  .option('-p, --provider <provider>', 'æ¤œç´¢ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ (duckduckgo|searxng)', 'duckduckgo')
  .option('-f, --format <format>', 'å‡ºåŠ›å½¢å¼ (json|text)', 'text')
  .action(async (query: string, options: { max: string; provider: string; format: string }) => {
    try {
      const client = new WebSearchClient();
      const provider = options.provider as 'duckduckgo' | 'searxng';
      const results = await client.search(query, { 
        maxResults: parseInt(options.max, 10),
        provider
      });
      
      if (options.format === 'json') {
        console.log(JSON.stringify(results, null, 2));
      } else {
        console.log(`\nğŸ” "${query}" ã®æ¤œç´¢çµæœ: ${results.length}ä»¶\n`);
        for (const r of results) {
          console.log(`ğŸ“„ ${r.title}`);
          console.log(`   ${r.url}`);
          if (r.snippet) {
            console.log(`   ${r.snippet.substring(0, 100)}...`);
          }
          console.log();
        }
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚³ãƒãƒ³ãƒ‰
program
  .command('scrape <url>')
  .description('Webãƒšãƒ¼ã‚¸ã®å†…å®¹ã‚’å–å¾—')
  .option('-f, --format <format>', 'å‡ºåŠ›å½¢å¼ (json|text)', 'text')
  .option('-s, --summary', 'è¦ç´„ã‚’è¡¨ç¤º', false)
  .action(async (url: string, options: { format: string; summary: boolean }) => {
    try {
      const scraper = new WebScraper();
      const result = await scraper.scrape(url);
      
      if (isErr(result)) {
        console.error('âŒ ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ—ã‚¨ãƒ©ãƒ¼:', result.error.message);
        process.exit(1);
      }

      const page = result.value;
      
      if (options.format === 'json') {
        console.log(JSON.stringify(page, null, 2));
      } else {
        console.log(`\nğŸ“„ ${page.title}`);
        console.log(`ğŸ”— ${page.url}`);
        console.log('\n---\n');
        
        if (options.summary) {
          const summarizer = new SummaryGenerator();
          const content = createContent(page.title, page.content, page.url);
          const summary = await summarizer.generateSummary(content, { maxLength: 500 });
          if (isOk(summary)) {
            console.log('ğŸ“ è¦ç´„:\n');
            console.log(summary.value);
          }
        } else {
          console.log(page.content.substring(0, 2000));
          if (page.content.length > 2000) {
            console.log(`\n... (${page.content.length - 2000}æ–‡å­—çœç•¥)`);
          }
        }
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// åˆ†æã‚³ãƒãƒ³ãƒ‰
program
  .command('analyze <text>')
  .description('ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ»æ„Ÿæƒ…åˆ†æï¼‰')
  .option('-f, --format <format>', 'å‡ºåŠ›å½¢å¼ (json|text)', 'text')
  .action(async (text: string, options: { format: string }) => {
    try {
      const analyzer = new TextAnalyzer();
      const result = await analyzer.analyze(text);
      
      if (options.format === 'json') {
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.log('\nğŸ“Š ãƒ†ã‚­ã‚¹ãƒˆåˆ†æçµæœ\n');
        console.log(`ğŸ”‘ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: ${result.keywords.join(', ')}`);
        console.log(`ğŸ’¬ æ„Ÿæƒ…: ${result.sentiment.sentiment}`);
        console.log(`ğŸ“ˆ æ„Ÿæƒ…ã‚¹ã‚³ã‚¢: ${result.sentiment.score.toFixed(2)}`);
        console.log(`ğŸ“ è¤‡é›‘åº¦: ${result.complexity.level} (${result.complexity.score})`);
        console.log(`ğŸ“„ å˜èªæ•°: ${result.wordCount}`);
        console.log(`ğŸ“„ æ–‡æ•°: ${result.sentenceCount}`);
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£æŠ½å‡ºã‚³ãƒãƒ³ãƒ‰
program
  .command('extract <text>')
  .description('ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æŠ½å‡º')
  .option('-f, --format <format>', 'å‡ºåŠ›å½¢å¼ (json|text)', 'text')
  .action(async (text: string, options: { format: string }) => {
    try {
      const extractor = new EntityExtractor();
      const entities = await extractor.extract(text);
      
      if (options.format === 'json') {
        console.log(JSON.stringify(entities, null, 2));
      } else {
        console.log('\nğŸ” ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£æŠ½å‡ºçµæœ\n');
        
        if (entities.persons.length > 0) {
          console.log(`ğŸ‘¤ äººå: ${entities.persons.join(', ')}`);
        }
        if (entities.organizations.length > 0) {
          console.log(`ğŸ¢ çµ„ç¹”: ${entities.organizations.join(', ')}`);
        }
        if (entities.locations.length > 0) {
          console.log(`ğŸ“ å ´æ‰€: ${entities.locations.join(', ')}`);
        }
        if (entities.dates.length > 0) {
          console.log(`ğŸ“… æ—¥ä»˜: ${entities.dates.join(', ')}`);
        }
        if (entities.urls.length > 0) {
          console.log(`ğŸ”— URL: ${entities.urls.join(', ')}`);
        }
        if (entities.emails.length > 0) {
          console.log(`ğŸ“§ ãƒ¡ãƒ¼ãƒ«: ${entities.emails.join(', ')}`);
        }
        if (entities.phones.length > 0) {
          console.log(`ğŸ“ é›»è©±: ${entities.phones.join(', ')}`);
        }
        if (entities.money.length > 0) {
          console.log(`ğŸ’° é‡‘é¡: ${entities.money.join(', ')}`);
        }
        
        console.log(`\nğŸ“Š åˆè¨ˆ: ${entities.all.length}ä»¶ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£`);
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// è¦ç´„ã‚³ãƒãƒ³ãƒ‰
program
  .command('summarize <text>')
  .description('ãƒ†ã‚­ã‚¹ãƒˆã‚’è¦ç´„')
  .option('-l, --length <number>', 'è¦ç´„ã®æœ€å¤§æ–‡å­—æ•°', '300')
  .option('-f, --format <format>', 'å‡ºåŠ›å½¢å¼ (json|text)', 'text')
  .action(async (text: string, options: { length: string; format: string }) => {
    try {
      const summarizer = new SummaryGenerator();
      const content = createContent('CLI Input', text);
      const result = await summarizer.generateSummary(content, { maxLength: parseInt(options.length, 10) });
      
      if (isErr(result)) {
        const error = result.error as Error;
        console.error('âŒ è¦ç´„ã‚¨ãƒ©ãƒ¼:', error.message);
        process.exit(1);
      }

      const summary = result.value;
      
      if (options.format === 'json') {
        console.log(JSON.stringify({ summary, originalLength: text.length }, null, 2));
      } else {
        console.log('\nğŸ“ è¦ç´„çµæœ\n');
        console.log(summary);
        console.log(`\n(å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ: ${text.length}æ–‡å­— â†’ è¦ç´„: ${summary.length}æ–‡å­—)`);
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// =============================================================================
// deep-research ã‚³ãƒãƒ³ãƒ‰ (v3.0.0 - MUSUBIXæº–æ‹ )
// =============================================================================
program
  .command('deep-research <topic>')
  .description('Deep Research v3.0.0 - MUSUBIXæº–æ‹ ã®åå¾©çš„æ·±æ˜ã‚Šèª¿æŸ»')
  .option('-i, --iterations <number>', 'æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ•°', '5')
  .option('-t, --tokens <number>', 'ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—', '15000')
  .option('--jina-key <key>', 'Jina API Key (JINA_API_KEYç’°å¢ƒå¤‰æ•°ã‚‚å¯)')
  .option('--openai-key <key>', 'OpenAI API Key (OPENAI_API_KEYç’°å¢ƒå¤‰æ•°ã‚‚å¯)')
  .option('--format <type>', 'å‡ºåŠ›å½¢å¼ (text/json)', 'text')
  .option('-o, --output <path>', 'ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜å…ˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ./Reports/<topic>.md)')
  .option('--debug', 'ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰', false)
  .action(async (topic: string, options: {
    iterations: string;
    tokens: string;
    jinaKey?: string;
    openaiKey?: string;
    format: string;
    output?: string;
    debug?: boolean;
  }) => {
    try {
      const jinaApiKey = options.jinaKey || process.env.JINA_API_KEY;
      const openaiApiKey = options.openaiKey || process.env.OPENAI_API_KEY;
      const maxIterations = parseInt(options.iterations, 10);
      const tokenBudget = parseInt(options.tokens, 10);
      const debug = options.debug ?? false;

      console.log(`\nğŸ”¬ Deep Research v3.0.0: "${topic}"\n`);
      console.log('è¨­å®š:');
      console.log(`  - æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ${maxIterations}`);
      console.log(`  - ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—: ${tokenBudget}`);
      console.log(`  - Jina API: ${jinaApiKey ? 'âœ… è¨­å®šæ¸ˆã¿' : 'âŒ æœªè¨­å®š (DuckDuckGoã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)'}`);
      console.log(`  - OpenAI API: ${openaiApiKey ? 'âœ… è¨­å®šæ¸ˆã¿' : 'âŒ æœªè¨­å®š (ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆLMã‚’ä½¿ç”¨)'}`);
      console.log('\nèª¿æŸ»ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...\n');

      // ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚’è¨­å®š
      const providerFactory = createProviderFactory(
        jinaApiKey ? { jinaApiKey } : undefined,
        debug
      );

      // LMReasoningã‚’è¨­å®š
      const lmReasoning = openaiApiKey
        ? createLMReasoning({
            provider: new FetchLMProvider(
              'https://api.openai.com/v1/chat/completions',
              openaiApiKey,
              'gpt-4o-mini'
            ),
            debug,
          })
        : createLMReasoning({ debug });

      // ResearchEngineã‚’ä½œæˆ
      const engine = new ResearchEngine({
        providerFactory,
        lmReasoning,
        debug,
      });

      const startTime = Date.now();

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã§é€²æ—ã‚’è¡¨ç¤º
      engine.on((event: ResearchEvent) => {
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        
        switch (event.type) {
          case 'iteration_start':
            console.log(`ğŸ“Š ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ${event.iteration}/${maxIterations} (${elapsed}s)`);
            break;
          case 'search_complete':
            console.log(`   ğŸ” æ¤œç´¢å®Œäº†: ${event.data?.resultCount ?? 0}ä»¶`);
            break;
          case 'read_complete':
            console.log(`   ğŸ“– èª­å–å®Œäº†: ${event.data?.urlsRead ?? 0}URL, ${event.data?.factsExtracted ?? 0}ä»¶ã®äº‹å®Ÿ`);
            break;
          case 'reason_complete':
            console.log(`   ğŸ§  æ¨è«–å®Œäº†: ${event.data?.tokensUsed ?? 0}ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨`);
            break;
          case 'iteration_complete':
            const eval_ = event.data?.evaluation as { confidence?: number } | undefined;
            if (eval_) {
              console.log(`   âœ… ä¿¡é ¼åº¦: ${((eval_.confidence ?? 0) * 100).toFixed(0)}%`);
            }
            console.log();
            break;
          case 'answer_found':
            const answerConf = (event.data?.confidence as number | undefined) ?? 0;
            console.log(`\nğŸ¯ å›ç­”ç™ºè¦‹ï¼ ä¿¡é ¼åº¦: ${(answerConf * 100).toFixed(0)}%\n`);
            break;
          case 'error':
            console.error(`   âŒ ã‚¨ãƒ©ãƒ¼: ${event.data?.error ?? 'Unknown'}`);
            break;
        }
      });

      // ãƒªã‚µãƒ¼ãƒå®Ÿè¡Œ
      const report = await engine.research({
        query: topic,
        maxIterations,
        tokenBudget,
        outputFormat: 'markdown',
        language: 'ja',
      });

      const totalTimeMs = Date.now() - startTime;

      if (options.format === 'json') {
        console.log(JSON.stringify(report, null, 2));
      } else {
        console.log('â”'.repeat(60));
        console.log('ğŸ¯ Deep Research å®Œäº†\n');
        
        console.log('ğŸ“ˆ çµ±è¨ˆ:');
        console.log(`   - ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ${report.metadata.iterations}`);
        console.log(`   - ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨é‡: ${report.metadata.tokensUsed}`);
        console.log(`   - å®Ÿè¡Œæ™‚é–“: ${(totalTimeMs / 1000).toFixed(1)}ç§’`);
        console.log(`   - ä¿¡é ¼åº¦: ${(report.metadata.confidence * 100).toFixed(0)}%`);
        console.log(`   - åé›†çŸ¥è­˜: ${report.metadata.knowledgeCount}ä»¶`);
        console.log(`   - è¨ªå•URL: ${report.metadata.urlsVisited}ä»¶`);
        
        console.log('\nğŸ“ æ¦‚è¦:');
        console.log(`   ${report.summary.substring(0, 200)}${report.summary.length > 200 ? '...' : ''}`);
        
        console.log('\nğŸ“‹ ä¸»è¦ãªç™ºè¦‹ï¼ˆå¼•ç”¨ä»˜ãï¼‰:');
        const referenceMap = new Map<string, string>();
        for (const ref of report.references) {
          referenceMap.set(ref.url, ref.id);
        }
        
        report.findings.slice(0, 5).forEach((finding: { statement: string; citations: string[]; confidence: number }, i: number) => {
          const citations = finding.citations
            .map((url: string) => referenceMap.get(url))
            .filter(Boolean)
            .map((id: string | undefined) => `[${id}]`)
            .join(' ');
          console.log(`   ${i + 1}. ${finding.statement.substring(0, 80)}${finding.statement.length > 80 ? '...' : ''}`);
          if (citations) {
            console.log(`      å¼•ç”¨: ${citations}`);
          }
        });
        
        if (report.findings.length > 5) {
          console.log(`   ... ä»– ${report.findings.length - 5} ä»¶`);
        }
        
        console.log('\nğŸ“š å‚è€ƒæ–‡çŒ®:');
        report.references.slice(0, 5).forEach((ref: Reference) => {
          console.log(`   [${ref.id}] ${ref.title} (${ref.url})`);
        });
        
        if (report.references.length > 5) {
          console.log(`   ... ä»– ${report.references.length - 5} ä»¶`);
        }
        
        // ãƒ¬ãƒãƒ¼ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        const sanitizedTopic = topic.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
        const outputPath = options.output || join('Reports', `${sanitizedTopic}.md`);
        
        // å¼•ç”¨ä»˜ãMarkdownãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        const reportContent = generateMarkdownReportV3(report);
        await saveReport(outputPath, reportContent);
        console.log(`\nğŸ“ ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜: ${outputPath}`);
        
        console.log('\nğŸ’¡ ãƒ’ãƒ³ãƒˆ:');
        console.log('   - --jina-key ã¾ãŸã¯ JINA_API_KEY ã§ Jina AI æ¤œç´¢ã‚’ä½¿ç”¨');
        console.log('   - --openai-key ã¾ãŸã¯ OPENAI_API_KEY ã§ GPT-4o-mini æ¨è«–ã‚’ä½¿ç”¨');
        console.log('   - --format json ã§å®Œå…¨ãªçµæœã‚’å–å¾—');
      }
    } catch (error) {
      console.error('âŒ ã‚¨ãƒ©ãƒ¼:', error instanceof Error ? error.message : error);
      if (options.debug) {
        console.error(error);
      }
      process.exit(1);
    }
  });

program.parse();
